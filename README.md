# 项目背景
在当今大规模分布式系统的背景下，需要可靠、高可用性的分布式数据存储系统。
传统的集中式数据库在面对大规模数据和高并发访问时可能面临单点故障和性能瓶的问题。

> notice：本项目的目的是学习Raft的原理，并实现一个简单的k-v存储数据库。因此并不适用于生产环境。

# 改进方向
## 分片
系统能够将键 “分片” 或分区到一组副本组上。分片是键 / 值对的子集，例如所有以 “a” 开头的键可能是一个分片等，通过分片可提高系统性能，因为每个副本组仅处理几个分片的放置和获取，并且这些组并行操作。

- 副本，每个副本负责处理分片的一部分。每个分片的数据由一个副本组负责，该副本组运行 Raft 协议，保证 **强一致性**。

- 分片控制器ShardCtrler，管理 **分片到副本组的映射** (`Shards -> gid`)，决定哪个副本组对应服务哪个分片，即管理配置信息。配置随时间变化，客户端咨询 分片控制器，寻找对应 key 的副本组，而 副本组会请求控制器，以找到需要装载的分片。
## 协程
### 增加对共享栈的支持
本项目的协程库是独立栈的形式，每个协程有自己的栈空间，优点是实现简单，协程切换开销相对较低，但是 比较耗内存，我们可以增加本项目对共享栈的支持，让协程在运行的时候都使用同一个栈空间，每次协程切换 时要把自身共享栈空间拷贝。回到该协程的时候，将之前保存的数据，重新拷贝到运行时栈中。
### 支持协程嵌套
本项目的协程只支持线程主协程与任务协程之间切换，无法在子协程“调用“新一层的子协程，也就是无法进行 协程的嵌套调用，可以增加对这个功能的支持，具体实现也可以参考libco，每个线程都有一份` stCoRoutineEnv_t`对象(协程的运行环境)，在线程第一次创建协程时被自动创建，同时也会创建主协程，并将指向主协程的指针放到`pCallStack[0]`里:最多支持128层的协程调用